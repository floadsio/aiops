"""Helpers for rendering user provided issue content safely."""

from __future__ import annotations

import re
from html.parser import HTMLParser
from typing import Iterable
from urllib.parse import urlsplit

import mistune
from markupsafe import Markup, escape

# Jira mention pattern: [~accountid:ID] or [~username]
_JIRA_MENTION_PATTERN = re.compile(r"\[~(?:accountid:)?([^\]]+)\]")

# GitHub/GitLab @username mention pattern
# Matches @username but not emails or already-wrapped spans
# Username: alphanumeric, hyphens, max 39 chars for GitHub (GitLab similar)
_AT_MENTION_PATTERN = re.compile(
    r'(?<!["\w@>])@([a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?)'
    r'(?![a-zA-Z0-9@.-])'  # Not followed by more username chars or email domain
)

# Tags typically returned by providers such as Jira when rendering descriptions,
# plus tags generated by Markdown renderers.
_ALLOWED_TAGS: set[str] = {
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "del",
    "div",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",  # For Jira inline images
    "li",
    "ol",
    "p",
    "pre",
    "span",
    "strong",
    "table",
    "tbody",
    "td",
    "th",
    "thead",
    "tr",
    "tt",  # Jira inline code (teletype)
    "u",
    "ul",
}
_SELF_CLOSING_TAGS = {"br", "hr", "img"}
_ALLOWED_ATTRS: dict[str, set[str]] = {
    "a": {"href", "rel", "target", "title"},
    "code": {"class"},
    "div": {"class", "style"},  # Jira uses inline styles for panels
    "img": {"src", "alt", "width", "height", "style"},  # Jira inline images
    "pre": {"class"},  # Jira uses class="code-java" etc.
    "span": {"class", "style"},  # Jira uses inline styles
    "table": {"class"},
    "td": {"colspan"},
    "th": {"colspan"},
    "ul": {"class", "type"},  # Jira uses class="alternate" and type="square"
}
_SAFE_URL_SCHEMES = {"http", "https", "mailto", "tel"}
_HTML_DETECTION_RE = re.compile(r"<\/?\w+[^>]*>")
_STRIP_CONTENT_TAGS = {"script", "style"}

# Patterns that suggest Markdown content (not exhaustive, but common indicators)
_MARKDOWN_PATTERNS = [
    re.compile(r"^#{1,6}\s+", re.MULTILINE),  # Headers
    re.compile(r"```[\s\S]*?```"),  # Code blocks
    re.compile(r"`[^`]+`"),  # Inline code
    re.compile(r"\[[^\]]+\]\([^\)]+\)"),  # Links
    re.compile(r"^\s*[-*+]\s+", re.MULTILINE),  # Unordered lists
    re.compile(r"^\s*\d+\.\s+", re.MULTILINE),  # Ordered lists
    re.compile(r"\*\*[^*]+\*\*"),  # Bold
    re.compile(r"__[^_]+__"),  # Bold (alternative)
    re.compile(r"\*[^*]+\*"),  # Italic
    re.compile(r"_[^_]+_"),  # Italic (alternative)
    re.compile(r"~~[^~]+~~"),  # Strikethrough (GitLab/GitHub)
    re.compile(r"^\s*>\s+", re.MULTILINE),  # Blockquotes
    re.compile(r"^\s*[-*_]{3,}\s*$", re.MULTILINE),  # Horizontal rules
    re.compile(r"- \[[x ]\]", re.IGNORECASE),  # Checkboxes
    re.compile(r"<([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>"),  # Email as markdown
    re.compile(r"!\[[^\]]*\]\([^\)]+\)"),  # Images
]

# Patterns that suggest Jira markup content (Confluence/Textile wiki markup)
_JIRA_MARKUP_PATTERNS = [
    re.compile(r"^h[1-6]\.\s+", re.MULTILINE),  # Headers: h1. h2. etc. (MUST have this)
    re.compile(r"\{code[:\}]"),  # Code blocks: {code} or {code:java}
    re.compile(r"\{noformat\}"),  # Noformat blocks: {noformat}
    re.compile(r"\{\{[^}]+\}\}"),  # Inline code: {{text}}
    re.compile(r"^\s*bq\.\s+", re.MULTILINE),  # Blockquote: bq.
    re.compile(r"^----+$", re.MULTILINE),  # Horizontal rule
    re.compile(r"^\|\|.+\|\|$", re.MULTILINE),  # Table header row
    re.compile(r"\[~(?:accountid:)?[^\]]+\]"),  # Jira mentions: [~user] or [~accountid:...]
]

# Create a Mistune instance for rendering Markdown
_markdown_renderer = mistune.create_markdown(
    plugins=["strikethrough", "footnotes", "table", "task_lists"]
)


def _is_safe_url(value: str) -> bool:
    stripped = value.strip()
    if not stripped:
        return False
    split = urlsplit(stripped)
    if split.scheme:
        return split.scheme.lower() in _SAFE_URL_SCHEMES
    # Permit fragment or relative links within the tracker detail context.
    return stripped.startswith(("/", "#"))


def _sanitize_attribute(name: str, value: str) -> str | None:
    if name == "href":
        return value if _is_safe_url(value) else None
    if name == "target":
        return value if value in {"_blank", "_self"} else None
    return value


class _IssueHTMLSanitizer(HTMLParser):
    """Basic HTML sanitizer that preserves a limited set of markup."""

    def __init__(self) -> None:
        super().__init__(convert_charrefs=True)
        self._parts: list[str] = []
        self._strip_content_depth = 0

    def _serialize_attrs(
        self, tag: str, attrs: Iterable[tuple[str, str | None]]
    ) -> str:
        allowed = _ALLOWED_ATTRS.get(tag)
        if not allowed:
            return ""

        serialized: list[str] = []
        for name, raw_value in attrs:
            if raw_value is None or name not in allowed:
                continue
            sanitized = _sanitize_attribute(name, raw_value)
            if sanitized is None:
                continue
            serialized.append(f' {name}="{escape(sanitized)}"')
        return "".join(serialized)

    def handle_starttag(self, tag: str, attrs) -> None:  # type: ignore[override]
        tag_lower = tag.lower()
        if tag_lower in _STRIP_CONTENT_TAGS:
            self._strip_content_depth += 1
            return
        if tag_lower not in _ALLOWED_TAGS:
            return
        attr_string = self._serialize_attrs(tag_lower, attrs)
        self._parts.append(f"<{tag_lower}{attr_string}>")

    def handle_startendtag(self, tag: str, attrs) -> None:  # type: ignore[override]
        tag_lower = tag.lower()
        if tag_lower in _STRIP_CONTENT_TAGS:
            return
        if tag_lower not in _ALLOWED_TAGS:
            return
        attr_string = self._serialize_attrs(tag_lower, attrs)
        if tag_lower in _SELF_CLOSING_TAGS:
            self._parts.append(f"<{tag_lower}{attr_string}>")
            return
        self._parts.append(f"<{tag_lower}{attr_string}></{tag_lower}>")

    def handle_endtag(self, tag: str) -> None:  # type: ignore[override]
        tag_lower = tag.lower()
        if tag_lower in _STRIP_CONTENT_TAGS:
            if self._strip_content_depth:
                self._strip_content_depth -= 1
            return
        if tag_lower not in _ALLOWED_TAGS or tag_lower in _SELF_CLOSING_TAGS:
            return
        self._parts.append(f"</{tag_lower}>")

    def handle_data(self, data: str) -> None:  # type: ignore[override]
        if self._strip_content_depth:
            return
        self._parts.append(str(escape(data)))

    def get_html(self) -> str:
        return "".join(self._parts)


def _sanitize_html(html: str) -> str:
    parser = _IssueHTMLSanitizer()
    parser.feed(html)
    parser.close()
    result = parser.get_html()
    # Post-process: wrap code-like patterns in <code> tags
    # Match patterns like {key="value"} or {key=value} that look like metric selectors
    result = _wrap_inline_code_patterns(result)
    return result


# Pattern for code-like content: {key="value", ...} or {key=value}
# Also matches metric_name{selector} patterns common in Prometheus/PromQL
_INLINE_CODE_PATTERN = re.compile(
    r'(?<!<)([a-zA-Z_][a-zA-Z0-9_]*\{[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*["\']?[^{}\n]+?["\']?\})'
    r'|'
    r'(?<![<\w])(\{[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*["\']?[^{}\n]+?["\']?\})(?![>\w])'
)


def _wrap_inline_code_patterns(html: str) -> str:
    """Wrap code-like patterns in <code> tags if not already in a code context."""

    def replace_match(match: re.Match) -> str:
        # Either group 1 (metric{selector}) or group 2 ({selector} alone)
        text = match.group(1) or match.group(2)
        return f'<code class="inline-code">{text}</code>'

    # Simple approach: only replace if not already inside a tag
    # Split by existing code/pre tags and only process text outside them
    parts = re.split(r'(<(?:code|pre)[^>]*>.*?</(?:code|pre)>)', html, flags=re.DOTALL)
    result = []
    for i, part in enumerate(parts):
        # Odd indices are the code/pre blocks, leave them alone
        if i % 2 == 1:
            result.append(part)
        else:
            result.append(_INLINE_CODE_PATTERN.sub(replace_match, part))
    return ''.join(result)


def _looks_like_html(text: str) -> bool:
    return bool(_HTML_DETECTION_RE.search(text))


def _looks_like_markdown(text: str) -> bool:
    """Detect if text contains Markdown syntax."""
    # Check for markdown patterns
    matches = sum(1 for pattern in _MARKDOWN_PATTERNS if pattern.search(text))
    # If we find any markdown pattern, treat it as markdown
    # (GitHub, GitLab, and other providers use markdown syntax)
    return matches >= 1


def _looks_like_jira_markup(text: str) -> bool:
    """Detect if text contains Jira markup syntax."""
    # Check for Jira markup patterns
    matches = sum(1 for pattern in _JIRA_MARKUP_PATTERNS if pattern.search(text))
    return matches >= 1


def _convert_jira_tables(text: str) -> str:
    """Convert Jira table markup to HTML tables.

    Jira tables use:
    - ||header|| for header cells
    - |cell| for regular cells
    """
    lines = text.split("\n")
    result = []
    in_table = False

    for line in lines:
        stripped = line.strip()

        # Header row: ||col1||col2||
        if stripped.startswith("||") and stripped.endswith("||"):
            if not in_table:
                result.append("<table>")
                in_table = True
            # Extract headers
            headers = [h.strip() for h in stripped.strip("|").split("||")]
            cells_html = "".join(f"<th>{h}</th>" for h in headers if h)
            result.append(f"<tr>{cells_html}</tr>")

        # Regular row: |col1|col2|
        elif stripped.startswith("|") and stripped.endswith("|") and not stripped.startswith("||"):
            if not in_table:
                result.append("<table>")
                in_table = True
            # Extract cells
            cells = [c.strip() for c in stripped.strip("|").split("|")]
            cells_html = "".join(f"<td>{c}</td>" for c in cells if c)
            result.append(f"<tr>{cells_html}</tr>")

        else:
            # Not a table row - close table if open
            if in_table:
                result.append("</table>")
                in_table = False
            result.append(line)

    # Close table if still open
    if in_table:
        result.append("</table>")

    return "\n".join(result)


def _convert_jira_markup_to_html(text: str) -> str:
    """Convert Jira markup (Confluence wiki markup) to HTML.

    Supports basic Jira markup patterns:
    - Headers: h1. through h6.
    - Bold: *text*
    - Italic: _text_
    - Deleted: -text-
    - Inserted: +text+
    - Inline code: {{text}}
    - Code blocks: {code}...{code}
    - Blockquotes: bq. text
    - Horizontal rules: ----
    - Lists: * and #
    """
    html = text

    # Extract code blocks first to protect them from other processing
    code_blocks: list[str] = []

    def save_code_block(match: re.Match) -> str:
        code_content = match.group(1)
        # Escape HTML in code blocks
        code_content = code_content.replace("&", "&amp;")
        code_content = code_content.replace("<", "&lt;")
        code_content = code_content.replace(">", "&gt;")
        placeholder = f"__CODE_BLOCK_{len(code_blocks)}__"
        code_blocks.append(f"<pre><code>{code_content}</code></pre>")
        return placeholder

    # Code blocks: {code}...{code} or {code:lang}...{code}
    html = re.sub(
        r"\{code(?::[^}]+)?\}([\s\S]*?)\{code\}",
        save_code_block,
        html,
    )

    # Also handle {noformat}...{noformat} blocks
    html = re.sub(
        r"\{noformat\}([\s\S]*?)\{noformat\}",
        save_code_block,
        html,
    )

    # Headers: h1. Header Text -> <h1>Header Text</h1>
    for level in range(1, 7):
        pattern = re.compile(rf"^h{level}\.\s+(.+)$", re.MULTILINE)
        html = pattern.sub(rf"<h{level}>\1</h{level}>", html)

    # Inline code: {{text}} -> <code>text</code>
    html = re.sub(r"\{\{([^}]+)\}\}", r"<code>\1</code>", html)

    # Blockquotes: bq. text -> <blockquote>text</blockquote>
    html = re.sub(r"^bq\.\s+(.+)$", r"<blockquote>\1</blockquote>", html, flags=re.MULTILINE)

    # Horizontal rules: ---- -> <hr>
    html = re.sub(r"^----+$", r"<hr>", html, flags=re.MULTILINE)

    # Tables: ||header||header|| -> <table><tr><th>header</th><th>header</th></tr>
    # and |cell|cell| -> <tr><td>cell</td><td>cell</td></tr>
    html = _convert_jira_tables(html)

    # Lists - numbered: # item -> <ol><li>item</li></ol>
    lines = html.split("\n")
    result_lines = []
    in_ol = False
    in_ul = False

    for line in lines:
        # Ordered list
        if re.match(r"^\s*#\s+", line):
            if not in_ol:
                if in_ul:
                    result_lines.append("</ul>")
                    in_ul = False
                result_lines.append("<ol>")
                in_ol = True
            item_text = re.sub(r"^\s*#\s+", "", line)
            result_lines.append(f"<li>{item_text}</li>")
        # Unordered list
        elif re.match(r"^\s*\*\s+", line):
            if not in_ul:
                if in_ol:
                    result_lines.append("</ol>")
                    in_ol = False
                result_lines.append("<ul>")
                in_ul = True
            item_text = re.sub(r"^\s*\*\s+", "", line)
            result_lines.append(f"<li>{item_text}</li>")
        else:
            if in_ol:
                result_lines.append("</ol>")
                in_ol = False
            if in_ul:
                result_lines.append("</ul>")
                in_ul = False
            result_lines.append(line)

    # Close any open lists
    if in_ol:
        result_lines.append("</ol>")
    if in_ul:
        result_lines.append("</ul>")

    html = "\n".join(result_lines)

    # Inline formatting (apply after lists and tables to avoid conflicts)
    # Bold: *text* -> <strong>text</strong>
    html = re.sub(r"\*([^*\n]+?)\*", r"<strong>\1</strong>", html)

    # Italic: _text_ -> <em>text</em>
    html = re.sub(r"\b_([^_\n]+?)_\b", r"<em>\1</em>", html)

    # Deleted: -text- -> <del>text</del> (require spaces around for safety)
    html = re.sub(r"(?<!\S)-([^-\n]+?)-(?!\S)", r"<del>\1</del>", html)

    # Inserted: +text+ -> <ins>text</ins> (require spaces around for safety)
    html = re.sub(r"(?<!\S)\+([^+\n]+?)\+(?!\S)", r"<ins>\1</ins>", html)

    # Wrap paragraphs: consecutive non-HTML lines become <p>...</p>
    lines = html.split("\n")
    result_lines = []
    in_paragraph = False
    paragraph_lines = []

    for line in lines:
        stripped = line.strip()
        # Check if line is already an HTML tag or a code block placeholder
        if stripped.startswith("<") or stripped.startswith("__CODE_BLOCK_") or not stripped:
            # Flush paragraph if we were building one
            if in_paragraph:
                result_lines.append("<p>" + " ".join(paragraph_lines) + "</p>")
                paragraph_lines = []
                in_paragraph = False
            # Add the HTML line as-is
            if stripped:
                result_lines.append(line)
        else:
            # Accumulate paragraph content
            if not in_paragraph:
                in_paragraph = True
            paragraph_lines.append(stripped)

    # Flush any remaining paragraph
    if in_paragraph and paragraph_lines:
        result_lines.append("<p>" + " ".join(paragraph_lines) + "</p>")

    html = "\n".join(result_lines)

    # Restore code blocks
    for i, code_block in enumerate(code_blocks):
        html = html.replace(f"__CODE_BLOCK_{i}__", code_block)

    return html


# Cache for Jira account ID to user name lookups
_jira_user_cache: dict[str, str] = {}
_jira_user_cache_loaded = False


def _load_jira_user_cache() -> None:
    """Load Jira account ID to user name mappings from database."""
    global _jira_user_cache, _jira_user_cache_loaded
    if _jira_user_cache_loaded:
        return

    try:
        # Import here to avoid circular imports
        from flask import current_app
        from app.models import User, UserIdentityMap

        # Only load if we're in an app context
        if not current_app:
            return

        # Query all user identity mappings with Jira account IDs
        mappings = (
            UserIdentityMap.query
            .join(User)
            .filter(UserIdentityMap.jira_account_id.isnot(None))
            .all()
        )
        for mapping in mappings:
            if mapping.jira_account_id and mapping.user:
                # Store both the full account ID and partial matches
                account_id = mapping.jira_account_id
                user_name = mapping.user.name or mapping.user.email or "User"
                _jira_user_cache[account_id] = user_name
                # Also store by the numeric prefix (e.g., "557058")
                if ':' in account_id:
                    prefix = account_id.split(':')[0]
                    if prefix not in _jira_user_cache:
                        _jira_user_cache[prefix] = user_name

        _jira_user_cache_loaded = True
    except Exception:
        # If we can't load the cache, we'll fall back to showing IDs
        pass


def _resolve_jira_user(account_id: str) -> str | None:
    """Resolve a Jira account ID to a user name."""
    _load_jira_user_cache()

    # Try exact match first
    if account_id in _jira_user_cache:
        return _jira_user_cache[account_id]

    # Try matching by numeric prefix (e.g., "557058" from "557058:uuid")
    if ':' in account_id:
        prefix = account_id.split(':')[0]
        if prefix in _jira_user_cache:
            return _jira_user_cache[prefix]

        # Try matching by any account ID that starts with the same prefix
        for cached_id, name in _jira_user_cache.items():
            if cached_id.startswith(prefix + ':') or cached_id == prefix:
                return name

    return None


def _convert_jira_mentions(text: str) -> str:
    """Convert Jira mentions [~accountid:...] to readable format.

    Converts [~accountid:ID] or [~username] patterns to
    @username format that's more readable. Uses the user_identity_map
    table to resolve account IDs to actual user names.

    Examples:
    - [~accountid:557058:5010d224-...] → @Ivo Marino (if mapped)
    - [~accountid:557058:5010d224-...] → @user:557058 (if not mapped)
    - [~jsmith] → @jsmith
    """
    def replace_mention(match):
        mention_id = match.group(1)

        # Try to resolve from user identity map
        resolved_name = _resolve_jira_user(mention_id)
        if resolved_name:
            return f'<span class="jira-mention">@{escape(resolved_name)}</span>'

        # Fall back to showing a reasonable identifier
        display_name = mention_id
        if ':' in mention_id:
            parts = mention_id.split(':')
            if len(parts) >= 2 and parts[0]:
                display_name = f"user:{parts[0]}"
            elif len(parts) >= 2:
                display_name = parts[-1][:8] if parts[-1] else "user"

        return f'<span class="jira-mention">@{escape(display_name)}</span>'

    return _JIRA_MENTION_PATTERN.sub(replace_mention, text)


# GitHub username cache
_github_user_cache: dict[str, str] = {}
_github_user_cache_loaded = False


def _load_github_user_cache() -> None:
    """Load GitHub username to display name mappings from database."""
    global _github_user_cache, _github_user_cache_loaded
    if _github_user_cache_loaded:
        return

    try:
        from flask import current_app
        from app.models import User, UserIdentityMap

        if not current_app:
            return

        mappings = (
            UserIdentityMap.query
            .join(User)
            .filter(UserIdentityMap.github_username.isnot(None))
            .all()
        )
        for mapping in mappings:
            if mapping.github_username and mapping.user:
                username = mapping.github_username.lower()
                display_name = mapping.user.name or mapping.user.email or mapping.github_username
                _github_user_cache[username] = display_name

        _github_user_cache_loaded = True
    except Exception:
        pass


def _resolve_github_user(username: str) -> str | None:
    """Resolve a GitHub username to a display name."""
    _load_github_user_cache()
    return _github_user_cache.get(username.lower())


# GitLab username cache
_gitlab_user_cache: dict[str, str] = {}
_gitlab_user_cache_loaded = False


def _load_gitlab_user_cache() -> None:
    """Load GitLab username to display name mappings from database."""
    global _gitlab_user_cache, _gitlab_user_cache_loaded
    if _gitlab_user_cache_loaded:
        return

    try:
        from flask import current_app
        from app.models import User, UserIdentityMap

        if not current_app:
            return

        mappings = (
            UserIdentityMap.query
            .join(User)
            .filter(UserIdentityMap.gitlab_username.isnot(None))
            .all()
        )
        for mapping in mappings:
            if mapping.gitlab_username and mapping.user:
                username = mapping.gitlab_username.lower()
                display_name = mapping.user.name or mapping.user.email or mapping.gitlab_username
                _gitlab_user_cache[username] = display_name

        _gitlab_user_cache_loaded = True
    except Exception:
        pass


def _resolve_gitlab_user(username: str) -> str | None:
    """Resolve a GitLab username to a display name."""
    _load_gitlab_user_cache()
    return _gitlab_user_cache.get(username.lower())


def _convert_at_mentions(text: str) -> str:
    """Convert @username mentions to styled spans with resolved display names.

    Checks both GitHub and GitLab user mappings to resolve usernames.
    Falls back to showing the original @username if not mapped.

    Examples:
    - @octocat → @Octo Cat (if mapped in GitHub)
    - @gitlabuser → @GitLab User (if mapped in GitLab)
    - @unknown → @unknown (if not mapped)
    """
    def replace_mention(match):
        username = match.group(1)

        # Try GitHub first, then GitLab
        resolved_name = _resolve_github_user(username) or _resolve_gitlab_user(username)
        if resolved_name:
            return f'<span class="user-mention">@{escape(resolved_name)}</span>'

        # Fall back to original username
        return f'<span class="user-mention">@{escape(username)}</span>'

    return _AT_MENTION_PATTERN.sub(replace_mention, text)


def render_issue_rich_text(value: str | None) -> Markup:
    """Render stored issue content (plain text, Markdown, or HTML) safely for templates."""
    if not value:
        return Markup("")

    stripped = value.strip()
    if not stripped:
        return Markup("")

    # First, convert Jira mentions to readable format
    with_mentions = _convert_jira_mentions(stripped)

    # Convert @username mentions (GitHub/GitLab style)
    with_mentions = _convert_at_mentions(with_mentions)

    is_html = _looks_like_html(with_mentions)
    is_markdown = _looks_like_markdown(with_mentions)
    is_jira = _looks_like_jira_markup(with_mentions)

    # If text looks like both HTML and Markdown, prefer Markdown.
    # Code blocks often contain <word> patterns (e.g., kubectl's <none>) that
    # falsely trigger HTML detection.
    if is_markdown:
        # Render Markdown to HTML
        markdown_result = _markdown_renderer(with_mentions)
        # Mistune can return str or list depending on renderer, we expect str
        if isinstance(markdown_result, str):
            # Sanitize the resulting HTML to ensure safety
            sanitized = _sanitize_html(markdown_result)
            if sanitized:
                return Markup(sanitized)

    # Check if it's Jira markup (before raw HTML, as Jira has distinct patterns)
    if is_jira:
        # Convert Jira markup to HTML
        jira_html = _convert_jira_markup_to_html(with_mentions)
        # Sanitize the resulting HTML to ensure safety
        sanitized = _sanitize_html(jira_html)
        if sanitized:
            return Markup(sanitized)

    # Check if it's HTML (only if not markdown/jira)
    if is_html:
        sanitized = _sanitize_html(with_mentions)
        if sanitized:
            # If HTML contains our mention spans + plain text, convert newlines to <br>
            # This handles the common case of plain text with mentions
            if '<span class="jira-mention">' in sanitized or '<span class="user-mention">' in sanitized:
                sanitized = sanitized.replace("\n", "<br>")
            return Markup(sanitized)

    # Fall back to treating the text as plain content and preserve newlines.
    escaped = str(escape(with_mentions))
    return Markup(escaped.replace("\n", "<br>"))
