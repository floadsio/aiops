{% extends "base.html" %}
{% block title %}AI Console | {{ project.name }}{% endblock %}
{% block content %}
<h1>AI Console: {{ project.name }}</h1>
<p><strong>Repository:</strong> <code>{{ project.repo_url }}</code></p>
<p><strong>Local Path:</strong> <code>{{ local_path }}</code></p>
<p>Launch an interactive terminal session inside the project workspace and drive Codex, Aider, or other configured assistants.</p>

<section id="terminal-container" class="terminal-wrapper">
<div class="terminal-toolbar">
  <div class="terminal-actions">
    <button type="button" id="fullscreen-toggle" class="secondary" aria-label="Toggle fullscreen">
      <span id="fullscreen-label">⛶</span>
    </button>
  </div>
</div>
  <div id="terminal" class="terminal-panel"></div>
</section>

<form id="ai-control">
  {{ form.hidden_tag() }}
  <input type="hidden" id="tmux_target" />
  <label>{{ form.ai_tool.label }} {{ form.ai_tool(id="ai_tool") }}</label>
  <label>Command <input type="text" id="command" value="{{ default_codex_command }}" /></label>
  <div id="codex_access_wrap" class="codex-access" hidden>
    <label>
      <span>Codex permissions</span>
      <select id="codex_access">
        <option value="never" selected>Full access (network + pushes)</option>
        <option value="on-failure">Safe (read/write on request)</option>
      </select>
    </label>
    <p class="text-muted codex-access__note">
      Safe mode lets Codex suggest commands but asks before running destructive steps.
      Full access enables `git push`, package installs, and full network access. Only use when you understand the impact.
    </p>
  </div>
  <label>{{ form.prompt.label }} {{ form.prompt(id="initial_prompt", rows=4, placeholder="Optional one-shot instruction to send when the session starts") }}</label>
  <label style="font-size: 0.9em;">
    <input type="checkbox" id="yolo_mode_checkbox" />
    <span style="color: #ff6b6b;" title="Skip all permissions for Claude (dangerous)">⚠️ Yolo Mode - Skip all permissions</span>
  </label>
  <div class="grid">
    <button type="submit" id="start-session">Start Session</button>
    <button type="button" id="stop-session" class="secondary">Stop Session</button>
  </div>
</form>

<!-- Resumable AI Sessions Section -->
<section class="resumable-sessions" id="resumable-sessions">
  <h2>Resumable AI Sessions</h2>
  <p class="text-muted">Continue previous Claude or Codex sessions</p>
  <div id="session-list" class="session-grid">
    <p class="text-muted">Loading sessions...</p>
  </div>
</section>

{% if tmux_error %}
  <article class="contrast">
    <strong>tmux unavailable</strong>
    <p>{{ tmux_error }}</p>
  </article>
{% elif tmux_windows %}
  <section class="tmux-session-summary">
    <h2>
      tmux windows for
      {% if project.tenant %}
        <span class="tenant-badge" style="--tenant-color: {{ project.tenant.color or default_tenant_color }}">
          <span class="tenant-badge__swatch" aria-hidden="true"></span>
          {{ project.tenant.name }}
        </span>
      {% else %}
        {{ project.name }}
      {% endif %}
    </h2>
    <p class="text-muted">Attach from your shell with <code>tmux attach -t &lt;session:window&gt;</code>.</p>
    <div class="tmux-session-grid">
      {% for session in tmux_windows %}
        <article class="tmux-card">
          <header>
            <span class="tmux-name">{{ session.window }}</span>
          </header>
          <p>{{ session.panes }} pane{{ '' if session.panes == 1 else 's' }}</p>
          {% if session.created_display %}
            <p class="text-muted">Started {{ session.created_display }}</p>
          {% else %}
            <p class="text-muted">Start time unavailable</p>
          {% endif %}
          <div class="tmux-card-actions">
            <button type="button" class="secondary attach-session" data-attach-session="{{ session.target }}">
              Attach in browser
            </button>
            <button type="button" class="tertiary copy-command" data-session-name="{{ session.target }}">
              Copy attach command
            </button>
            <button type="button" class="close-tmux-window" data-project-id="{{ project.id }}" data-tmux-target="{{ session.target }}" data-window-name="{{ session.window }}" title="Close window" style="padding: 0.2rem 0.35rem; font-size: 0.9rem; background: transparent; border: none; color: #64748b; cursor: pointer;">
              ×
            </button>
          </div>
        </article>
      {% endfor %}
    </div>
  </section>
{% endif %}

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
<style>
  @font-face {
    font-family: 'JetBrainsMono Nerd Font Mono';
    src: url('https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@master/patched-fonts/JetBrainsMono/Regular/complete/JetBrainsMonoNerdFontMono-Regular.woff2') format('woff2');
    font-weight: 400;
    font-style: normal;
    font-display: swap;
  }
  .codex-access {
    margin: 0 0 1rem 0;
    padding: 0.75rem 1rem;
    border-radius: 0.75rem;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(148, 163, 184, 0.08);
  }
  [data-theme="dark"] .codex-access {
    background: rgba(148, 163, 184, 0.15);
    border-color: rgba(148, 163, 184, 0.4);
  }
  .codex-access label {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    margin: 0;
  }
  .codex-access__note {
    margin: 0.35rem 0 0;
    font-size: 0.85rem;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.js"></script>
<script>
  const projectId = {{ project.id }};
  const requestedTmuxTarget = {{ requested_tmux_target|tojson }};

  // Extract issue_id and tool from URL parameters if present
  const urlParams = new URLSearchParams(window.location.search);
  const issueId = urlParams.get('issue_id') ? parseInt(urlParams.get('issue_id'), 10) : null;
  const requestedTool = urlParams.get('tool') || null;
  console.log('DEBUG: URL params - tool:', requestedTool, 'attach:', urlParams.get('attach'));
  const terminalPanel = document.getElementById('terminal');
  const term = new Terminal({ cols: 100, rows: 30, scrollback: 2000, convertEol: false });
  const fitAddon = window.FitAddon && typeof window.FitAddon.FitAddon === 'function'
    ? new window.FitAddon.FitAddon()
    : null;

  if (fitAddon) {
    term.loadAddon(fitAddon);
  }

  if (terminalPanel) {
    term.open(terminalPanel);
    if (term.element) {
      term.element.addEventListener(
        'wheel',
        event => {
          event.preventDefault();
        },
        { passive: false }
      );
    }
  }

  term.write('\x1b[32mReady. Choose an AI tool or attach to an existing tmux session.\x1b[0m\n');

  const csrfInput = document.querySelector('#ai-control input[name="csrf_token"]');
  const csrfMeta = document.querySelector('meta[name="csrf-token"]');
  const csrfTokenValue = (
    (csrfInput && csrfInput.value) ||
    (csrfMeta && csrfMeta.getAttribute('content')) ||
    ''
  );
  const csrfHeaders = csrfTokenValue
    ? { 'X-CSRFToken': csrfTokenValue, 'X-CSRF-Token': csrfTokenValue }
    : {};
  const supportsUtf8Write = typeof term.writeUtf8 === 'function';
  const canDecodeText = !supportsUtf8Write && window.TextDecoder;
  let sessionDecoder = canDecodeText ? new TextDecoder('utf-8') : null;
  const terminalWrapper = document.getElementById('terminal-container');
  const fullscreenToggle = document.getElementById('fullscreen-toggle');
  const fullscreenLabel = document.getElementById('fullscreen-label');
  const supportsNativeFullscreen = Boolean(
    terminalWrapper && terminalWrapper.requestFullscreen && document.fullscreenEnabled !== false
  );
  let fallbackFullscreen = false;

  let eventSource = null;
  let dataDisposable = null;
  let sessionId = null;
  let inputBuffer = '';
  let flushTimer = null;
  let resizeTimer = null;
  let pendingResize = null;
  let pendingFit = false;
  let visibilityHandler = null;

  const aiForm = document.getElementById('ai-control');
  const tmuxTargetInput = document.getElementById('tmux_target');
  const aiToolSelect = document.getElementById('ai_tool');
  const commandInput = document.getElementById('command');
  const promptInput = document.getElementById('initial_prompt');
  const aiToolCommands = {{ ai_tool_commands|tojson }};
  const codexAccessWrap = document.getElementById('codex_access_wrap');
  const codexAccessSelect = document.getElementById('codex_access');
  const codexAccessValues = new Set(['never', 'on-failure']);
  const sessionStorageKey = `aiops-session-context-${projectId}`;
  let storedSessionContext = null;
  let storedContextTool = null;
  let plannedPrompt = '';
  let pendingPrompt = false;
  let commandAutofill = true;

  function stripHtmlTags(text) {
    if (!text) {
      return '';
    }
    return text
      .replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '')
      .replace(/<style[\s\S]*?>[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  async function parseJsonResponse(response, {
    errorMessage = 'Request failed.',
    invalidBodyMessage = 'Server returned an invalid response.',
  } = {}) {
    const rawText = await response.text();
    const trimmed = rawText ? rawText.trim() : '';
    let parsed = null;

    if (trimmed) {
      try {
        parsed = JSON.parse(trimmed);
      } catch {
        parsed = null;
      }
    }

    if (!response.ok) {
      const message =
        (parsed && (parsed.error || parsed.message || parsed.detail)) ||
        stripHtmlTags(trimmed) ||
        `${errorMessage}${response.status ? ` (status ${response.status})` : ''}`;
      const error = new Error(message);
      error.status = response.status;
      throw error;
    }

    if (parsed !== null) {
      return parsed;
    }

    if (!trimmed) {
      return {};
    }

    throw new Error(invalidBodyMessage);
  }

  function applyToolDefault(toolValue, { force = false } = {}) {
    if (!commandInput || !toolValue) {
      return;
    }
    const targetCommand = aiToolCommands && aiToolCommands[toolValue];
    if (!targetCommand) {
      return;
    }
    const currentValue = (commandInput.value || '').trim();
    if (force || commandAutofill || !currentValue) {
      commandInput.value = targetCommand;
      commandAutofill = true;
      if (toolValue === 'codex') {
        syncCodexAccessFromCommand();
      }
    }
  }

  function getCodexAccessValue(command) {
    if (!command) {
      return 'never';
    }
    const askMatch = command.match(/--ask-for-approval(?:\s+|=)([^\s]+)/);
    if (askMatch) {
      return askMatch[1];
    }
    const legacyMatch = command.match(/-a\s+([^\s]+)/);
    return legacyMatch ? legacyMatch[1] : 'never';
  }

  function syncCodexAccessFromCommand() {
    if (!codexAccessSelect || !commandInput) {
      return;
    }
    const value = getCodexAccessValue(commandInput.value || '');
    if (codexAccessValues.has(value)) {
      codexAccessSelect.value = value;
    }
  }

  function applyCodexAccess(value) {
    if (!commandInput) {
      return;
    }
    const base = (aiToolCommands && aiToolCommands.codex) || 'codex';
    const current = (commandInput.value || '').trim();
    const replacement = `--ask-for-approval ${value}`;
    if (!current) {
      commandInput.value = `${base} ${replacement}`.trim();
      return;
    }
    const askPattern = /--ask-for-approval(?:\s+|=)[^\s]+/;
    const legacyPattern = /-a\s+[^\s]+/;
    if (askPattern.test(current)) {
      commandInput.value = current.replace(askPattern, replacement);
    } else if (legacyPattern.test(current)) {
      commandInput.value = current.replace(legacyPattern, replacement);
    } else {
      commandInput.value = `${current} ${replacement}`.trim();
    }
    commandAutofill = false;
  }

  function toggleCodexAccessVisibility() {
    if (!codexAccessWrap) {
      return;
    }
    const isCodex = aiToolSelect && aiToolSelect.value === 'codex';
    codexAccessWrap.hidden = !isCodex;
    if (isCodex) {
      syncCodexAccessFromCommand();
    }
  }

  if (commandInput) {
    commandInput.addEventListener('input', () => {
      commandAutofill = false;
    });
    commandInput.addEventListener('change', () => {
      if (aiToolSelect && aiToolSelect.value === 'codex') {
        syncCodexAccessFromCommand();
      }
    });
  }

  if (aiToolSelect) {
    aiToolSelect.addEventListener('change', event => {
      const value = event.target.value;
      if (!value) {
        commandAutofill = false;
      } else {
        applyToolDefault(value);
      }
      toggleCodexAccessVisibility();
    });
  }
  toggleCodexAccessVisibility();

  if (codexAccessSelect) {
    codexAccessSelect.addEventListener('change', event => {
      const value = event.target.value;
      if (!codexAccessValues.has(value)) {
        return;
      }
      applyCodexAccess(value);
    });
  }

  function consumeStoredContext() {
    try {
      const payload = sessionStorage.getItem(sessionStorageKey);
      if (!payload) {
        return null;
      }
      sessionStorage.removeItem(sessionStorageKey);
      return JSON.parse(payload);
    } catch (error) {
      return null;
    }
  }

  function applySessionContext(context) {
    if (!context) {
      return false;
    }
    storedSessionContext = context;
    storedContextTool = context.tool || null;
    if (context.tool && aiToolSelect) {
      const optionExists = Array.from(aiToolSelect.options).some(opt => opt.value === context.tool);
      if (optionExists) {
        aiToolSelect.value = context.tool;
      }
    }
    const configuredCommand = (aiToolCommands && context.tool) ? aiToolCommands[context.tool] : '';
    const currentCommand = (context.command || '').trim();
    if (commandInput) {
      const configuredToken = (configuredCommand || '').trim().split(/\s+/)[0] || '';
      const currentToken = currentCommand ? currentCommand.split(/\s+/)[0] : '';
      const shouldForceDefault =
        !currentCommand ||
        (configuredToken && currentToken && configuredToken.toLowerCase() !== currentToken.toLowerCase());

      if (shouldForceDefault && configuredCommand) {
        commandInput.value = configuredCommand;
        commandAutofill = true;
      } else if (currentCommand) {
        commandInput.value = currentCommand;
        commandAutofill = false;
      }

      if (aiToolSelect && aiToolSelect.value === 'codex') {
        syncCodexAccessFromCommand();
      }
    }
    if (typeof context.prompt === 'string') {
      plannedPrompt = context.prompt;
      if (promptInput) {
        promptInput.value = context.prompt;
      }
      pendingPrompt = Boolean(plannedPrompt && plannedPrompt.trim());
    } else {
      plannedPrompt = '';
      pendingPrompt = false;
      if (promptInput) {
        promptInput.value = '';
      }
    }
    if (context.tmuxTarget && tmuxTargetInput) {
      tmuxTargetInput.value = context.tmuxTarget;
    }
    toggleCodexAccessVisibility();
    return Boolean(context.autoStart);
  }

  const storedContext = consumeStoredContext();
  const shouldAutoStart = applySessionContext(storedContext);
  // Auto-start if context says to, even if there's a requested tmux target
  // Only skip auto-start if tmux target came from URL (not from stored context)
  const tmuxTargetFromUrl = requestedTmuxTarget && !storedContext;
  let autoStartPending = shouldAutoStart && !tmuxTargetFromUrl;

  function base64ToBytes(payload) {
    const binary = atob(payload);
    const bytes = new Uint8Array(binary.length);
    for (let index = 0; index < binary.length; index += 1) {
      bytes[index] = binary.charCodeAt(index);
    }
    return bytes;
  }

  function flushDecoder() {
    if (!sessionDecoder) {
      return '';
    }
    const remainder = sessionDecoder.decode();
    sessionDecoder = canDecodeText ? new TextDecoder('utf-8') : null;
    return remainder;
  }

  function flushResizeUpdate() {
    if (!sessionId || !pendingResize) {
      pendingResize = null;
      return;
    }
    const payload = pendingResize;
    pendingResize = null;
    fetch(`/projects/${projectId}/ai/session/${sessionId}/resize`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...csrfHeaders },
      body: JSON.stringify(payload),
      credentials: 'same-origin'
    }).catch(() => {});
  }

  function queueResizeUpdate() {
    if (!sessionId) {
      return;
    }
    const rows = Math.max(1, Math.floor(term.rows || 0));
    const cols = Math.max(1, Math.floor(term.cols || 0));
    pendingResize = { rows, cols };
    if (resizeTimer) {
      return;
    }
    resizeTimer = setTimeout(() => {
      resizeTimer = null;
      flushResizeUpdate();
    }, 120);
  }

  function fitTerminal() {
    if (!fitAddon || !terminalPanel) {
      return;
    }
    try {
      fitAddon.fit();
    } catch (error) {
      // Ignore fit errors triggered while the panel is hidden.
    }
    queueResizeUpdate();
  }

  function scheduleFit() {
    if (!fitAddon || !terminalPanel) {
      return;
    }
    if (pendingFit) {
      return;
    }
    pendingFit = true;
    const runFit = () => {
      pendingFit = false;
      fitTerminal();
    };
    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(runFit);
    } else {
      setTimeout(runFit, 0);
    }
  }

  function writeChunk(payload) {
    try {
      const bytes = base64ToBytes(payload);
      if (supportsUtf8Write) {
        term.writeUtf8(bytes);
        return;
      }
      if (sessionDecoder) {
        const text = sessionDecoder.decode(bytes, { stream: true });
        if (text) {
          term.write(text);
        }
        return;
      }
      term.write(String.fromCharCode(...bytes));
    } catch (error) {
      term.write(payload);
    }
  }

  function isFullscreen() {
    if (!terminalWrapper) {
      return false;
    }
    if (supportsNativeFullscreen) {
      return document.fullscreenElement === terminalWrapper;
    }
    return fallbackFullscreen;
  }

  function applyFullscreenState(active) {
    if (terminalWrapper) {
      terminalWrapper.classList.toggle('fullscreen', active);
    }
    if (fullscreenLabel) {
      fullscreenLabel.textContent = active ? '⨯' : '⛶';
    }
  }

  function updateFullscreenButton() {
    applyFullscreenState(isFullscreen());
  }

  if (fullscreenToggle && terminalWrapper) {
    fullscreenToggle.addEventListener('click', () => {
      if (supportsNativeFullscreen) {
        if (isFullscreen()) {
          document.exitFullscreen().catch(() => {});
        } else {
          terminalWrapper.requestFullscreen().catch(() => {
            fallbackFullscreen = !fallbackFullscreen;
            applyFullscreenState(fallbackFullscreen);
            scheduleFit();
          });
        }
      } else {
        fallbackFullscreen = !fallbackFullscreen;
        applyFullscreenState(fallbackFullscreen);
        scheduleFit();
      }
    });

    if (supportsNativeFullscreen) {
      const handleFullscreenChange = () => {
        applyFullscreenState(isFullscreen());
        scheduleFit();
      };
      document.addEventListener('fullscreenchange', handleFullscreenChange);
    } else {
      applyFullscreenState(fallbackFullscreen);
    }
  }

  if (terminalPanel) {
    window.addEventListener('resize', scheduleFit);
    if ('ResizeObserver' in window) {
      const observer = new ResizeObserver(() => scheduleFit());
      observer.observe(terminalPanel);
      if (terminalWrapper) {
        observer.observe(terminalWrapper);
      }
    }
  }

  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(() => scheduleFit()).catch(() => {});
  }

  function flushInput() {
    if (!sessionId || !inputBuffer) {
      return;
    }
    const payload = inputBuffer;
    inputBuffer = '';
    fetch(`/projects/${projectId}/ai/session/${sessionId}/input`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...csrfHeaders },
      body: JSON.stringify({ data: payload }),
      credentials: 'same-origin'
    });
  }

  function queueInput(data) {
    inputBuffer += data;
    if (!flushTimer) {
      flushTimer = setTimeout(() => {
        flushTimer = null;
        flushInput();
      }, 40);
    }
  }

  function stopSession(message) {
    if (flushTimer) {
      clearTimeout(flushTimer);
      flushTimer = null;
    }
    flushInput();
    if (dataDisposable) {
      dataDisposable.dispose();
      dataDisposable = null;
    }
    // Clean up visibility handler before closing eventSource
    if (visibilityHandler) {
      document.removeEventListener('visibilitychange', visibilityHandler);
      visibilityHandler = null;
    }
    if (eventSource) {
      eventSource.close();
      eventSource = null;
    }
    if (resizeTimer) {
      clearTimeout(resizeTimer);
      resizeTimer = null;
    }
    pendingResize = null;
    if (sessionId) {
      fetch(`/projects/${projectId}/ai/session/${sessionId}`, {
        method: 'DELETE',
        headers: csrfHeaders,
        credentials: 'same-origin'
      });
      sessionId = null;
    }
    term.write(flushDecoder());
    if (message) {
      term.write(`\n${message}\n`);
    }
    scheduleFit();
  }

  function startSession(options = {}) {
    const { tmuxTargetOverride } = options;
    const attachOnly = Boolean(tmuxTargetOverride);
    // When attaching to existing session, prioritize requestedTool from URL over dropdown
    const tool = attachOnly
      ? (requestedTool || (aiToolSelect && aiToolSelect.value) || storedContextTool || '')
      : ((aiToolSelect && aiToolSelect.value) || requestedTool || storedContextTool || '');
    // When attaching to existing session, ignore command input (tool from URL is authoritative)
    const command = attachOnly ? '' : commandInput.value.trim();
    console.log('DEBUG: startSession - attachOnly:', attachOnly, 'tool:', tool, 'command:', command, 'aiToolSelect:', aiToolSelect?.value, 'requestedTool:', requestedTool);
    const selectedTmuxTarget = attachOnly
      ? tmuxTargetOverride
      : (tmuxTargetInput ? tmuxTargetInput.value.trim() : '');

    if (!tool && !command && !selectedTmuxTarget) {
      term.write('\n\x1b[31mProvide an AI tool, command, or choose a tmux window to attach.\x1b[0m\n');
      return;
    }

    stopSession();

    scheduleFit();

    const sessionLabel = selectedTmuxTarget
      ? `tmux:${selectedTmuxTarget}`
      : (command ? command.split(' ')[0] : (tool || 'shell'));
    term.write(`\n[Starting ${sessionLabel}]\n`);

    if (!plannedPrompt && promptInput) {
      plannedPrompt = promptInput.value.trim();
    }
    pendingPrompt = Boolean(plannedPrompt);

    const { cols, rows } = term;

    const payload = {
      tool: tool || null,
      command: command || null,
      prompt: '',
      cols,
      rows,
      issue_id: issueId
    };

    // Add permission mode if specified in stored context or yolo checkbox
    const yoloCheckbox = document.getElementById('yolo_mode_checkbox');
    if (storedSessionContext && storedSessionContext.permissionMode) {
      payload.permission_mode = storedSessionContext.permissionMode;
    } else if (yoloCheckbox && yoloCheckbox.checked) {
      payload.permission_mode = 'yolo';
    }

    if (selectedTmuxTarget && attachOnly) {
      payload.tmux_target = selectedTmuxTarget;
      // Don't null out tool/command - preserve them for the backend session
      // The backend needs to know what tool is running in the tmux session
      if (aiToolSelect) {
        aiToolSelect.value = '';
      }
      if (commandInput) {
        commandInput.value = '';
        commandAutofill = false;
      }
      term.write(`\n[Attaching to tmux target ${selectedTmuxTarget}]\n`);
    } else if (selectedTmuxTarget && tmuxTargetInput) {
      tmuxTargetInput.value = selectedTmuxTarget;
    }

    fetch(`/projects/${projectId}/ai/session`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...csrfHeaders },
      credentials: 'same-origin',
      body: JSON.stringify(payload)
    })
      .then(response => parseJsonResponse(response, {
        errorMessage: 'Failed to start session',
        invalidBodyMessage: 'The server returned an invalid session response.',
      }))
      .then(data => {
        sessionId = data.session_id;
        const label = selectedTmuxTarget ? `tmux:${selectedTmuxTarget}` : (tool ? tool : (command || 'shell'));
        term.write(`\n[Connected to ${label}]\n`);

        // Setup EventSource connection with reconnection support
        function connectEventSource() {
          if (eventSource) {
            eventSource.close();
          }

          eventSource = new EventSource(`/projects/${projectId}/ai/session/${sessionId}/stream`);

          eventSource.addEventListener('ready', () => {
            term.write('\n[Session ready]\n');
            queueResizeUpdate();
            scheduleFit();
            if (pendingPrompt && plannedPrompt) {
              term.write(`[Submitting prompt]\n${plannedPrompt}\n`);
              queueInput(`${plannedPrompt}\n`);
              pendingPrompt = false;
            }
          });

          eventSource.addEventListener('chunk', (evt) => {
            writeChunk(evt.data);
          });

          eventSource.addEventListener('close', () => {
            term.write(flushDecoder());
            stopSession('[Session closed]');
          });

          eventSource.onerror = () => {
            // Check if session is still valid (server may have closed it)
            if (!sessionId) {
              return;
            }

            // If tab is hidden, don't react - we'll reconnect when visible
            if (document.hidden) {
              console.log('EventSource error while tab hidden - will reconnect when visible');
              return;
            }

            // Check connection state - if CLOSED, session truly ended
            if (eventSource.readyState === EventSource.CLOSED) {
              console.log('EventSource CLOSED - checking if session still active');
              // Verify with server if session is still alive
              fetch(`/projects/${projectId}/ai/session/${sessionId}/status`, {
                method: 'GET',
                headers: csrfHeaders,
                credentials: 'same-origin'
              }).then(response => {
                if (response.ok) {
                  console.log('Session still active, reconnecting...');
                  connectEventSource();
                } else {
                  console.log('Session no longer active, closing');
                  term.write(flushDecoder());
                  stopSession('[Session closed]');
                }
              }).catch(() => {
                // Network error - try reconnecting
                console.log('Network error checking status, attempting reconnect');
                setTimeout(connectEventSource, 1000);
              });
              return;
            }

            // CONNECTING state - browser is trying to reconnect, let it
            console.log('EventSource error, readyState:', eventSource.readyState);
          };
        }

        // Handle tab visibility changes - assign to module-level variable for cleanup
        visibilityHandler = () => {
          if (!document.hidden && sessionId) {
            // Tab became visible and we have a session
            if (!eventSource || eventSource.readyState === EventSource.CLOSED) {
              console.log('Tab visible, reconnecting EventSource...');
              term.write('\n[Reconnecting...]\n');
              connectEventSource();
            }
          }
        };
        document.addEventListener('visibilitychange', visibilityHandler);

        connectEventSource();

        dataDisposable = term.onData(dataChunk => {
          if (sessionId) {
            queueInput(dataChunk);
          }
        });

        if (tmuxTargetInput) {
          tmuxTargetInput.value = '';
        }

        queueResizeUpdate();
        scheduleFit();
      })
      .catch(err => {
        term.write(`\n\x1b[31m${err.message}\x1b[0m\n`);
      });
  }

  aiForm.addEventListener('submit', function (event) {
    event.preventDefault();
    startSession();
  });

  document.getElementById('stop-session').addEventListener('click', function () {
    stopSession('[Session terminated by user]');
  });

  document.querySelectorAll('.attach-session').forEach(button => {
    button.addEventListener('click', () => {
      const targetSession = button.dataset.attachSession;
      startSession({ tmuxTargetOverride: targetSession });
    });
  });

  document.querySelectorAll('.copy-command').forEach(button => {
    button.addEventListener('click', () => {
      const sessionName = button.dataset.sessionName;
      const commandText = `tmux attach -t ${sessionName}`;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(commandText)
          .then(() => term.write(`\n[Copied "${commandText}" to clipboard]\n`))
          .catch(() => term.write('\n\x1b[31mFailed to copy to clipboard.\x1b[0m\n'));
      } else {
        term.write('\n\x1b[31mClipboard API unavailable.\x1b[0m\n');
      }
    });
  });

  // Close tmux window handler
  document.querySelectorAll('.close-tmux-window').forEach(button => {
    button.addEventListener('click', (event) => {
      event.preventDefault();
      const projectId = button.dataset.projectId;
      const tmuxTarget = button.dataset.tmuxTarget;
      const windowName = button.dataset.windowName;

      if (!projectId || !tmuxTarget) {
        return;
      }

      if (!confirm(`Are you sure you want to close tmux window ${windowName || tmuxTarget}?`)) {
        return;
      }

      const url = `/projects/${projectId}/tmux/close`;
      const originalLabel = button.textContent;
      button.disabled = true;
      button.textContent = 'Closing...';

      fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...csrfHeaders,
        },
        body: JSON.stringify({
          tmux_target: tmuxTarget,
        }),
      })
      .then(response => response.json().then(data => ({ ok: response.ok, data })))
      .then(({ ok, data }) => {
        if (ok) {
          // Remove the tmux card
          const tmuxCard = button.closest('.tmux-card');
          if (tmuxCard) {
            tmuxCard.remove();
            term.write(`\n[Closed tmux window ${windowName || tmuxTarget}]\n`);
          }
          // Show warning if tmux close failed but database was updated
          if (data.warning) {
            console.warn(data.warning);
            alert(`Session closed (with warning): ${data.warning}`);
          }
        } else {
          throw new Error(data.error || 'Failed to close window.');
        }
      })
      .catch(error => {
        alert(`Error: ${error.message}`);
        button.disabled = false;
        button.textContent = originalLabel;
      });
    });
  });

  scheduleFit();
  setTimeout(scheduleFit, 250);
  updateFullscreenButton();

  if (requestedTmuxTarget) {
    startSession({ tmuxTargetOverride: requestedTmuxTarget });
  } else if (autoStartPending) {
    term.write('\n[Preparing Codex session with selected issue]\n');
    setTimeout(() => {
      startSession();
    }, 150);
  }
</script>

<style>
  .terminal-wrapper {
    margin: 0;
    border: 1px solid var(--muted-border-color);
    border-radius: var(--border-radius);
    background: #111;
    padding: 0.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
  }

  .terminal-toolbar {
    display: flex;
    align-items: center;
    justify-content: flex-end;
  }

  .terminal-actions {
    display: flex;
    align-items: center;
    gap: 0.2rem;
  }

  .terminal-actions button {
    padding: 0.05rem 0.3rem;
    font-size: 0.75rem;
    line-height: 1;
  }

  .terminal-panel {
    width: 100%;
    min-height: 320px;
    height: clamp(320px, 65vh, 900px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: var(--border-radius);
    padding: 0.25rem;
    background: #111;
    box-sizing: border-box;
    overflow: hidden;
  }

  .terminal-panel .xterm,
  .terminal-panel .xterm * {
    font-family: 'JetBrainsMono Nerd Font Mono', 'JetBrains Mono', monospace;
  }

  .terminal-panel .xterm-viewport {
    overflow: hidden !important;
  }

  .terminal-wrapper.fullscreen {
    position: fixed;
    inset: 0;
    margin: 0;
    border-radius: 0;
    border: none;
    z-index: 1000;
    padding: 0.15rem;
    gap: 0.15rem;
  }

  .terminal-wrapper.fullscreen .terminal-panel {
    height: auto;
    flex: 1 1 auto;
    min-height: 0;
  }

  @supports (height: 100dvh) {
    .terminal-wrapper.fullscreen .terminal-panel {
      height: auto;
      flex: 1 1 auto;
      min-height: 0;
    }
  }

  .tmux-session-summary {
    margin: 2rem 0;
    padding: 1.5rem;
    border-radius: 1rem;
    border: 1px solid rgba(100, 116, 139, 0.25);
    background: rgba(26, 29, 35, 0.04);
  }

  [data-theme="dark"] .tmux-session-summary {
    background: rgba(26, 29, 35, 0.55);
    border-color: rgba(148, 163, 184, 0.25);
  }

  .tmux-session-summary h2 {
    margin-top: 0;
    margin-bottom: 0.5rem;
  }

  .tmux-session-grid {
    margin-top: 1rem;
    display: grid;
    gap: 1rem;
  }

  @media (min-width: 640px) {
    .tmux-session-grid {
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }
  }

  .tmux-card {
    padding: 1rem 1.25rem;
    border-radius: 0.9rem;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(255, 255, 255, 0.82);
    box-shadow: 0 10px 35px rgba(26, 29, 35, 0.08);
  }

  [data-theme="dark"] .tmux-card {
    background: rgba(26, 29, 35, 0.7);
    border-color: rgba(148, 163, 184, 0.35);
    box-shadow: 0 16px 40px rgba(26, 29, 35, 0.55);
  }

  .tmux-card .tmux-name {
    display: inline-flex;
    padding: 0.35rem 0.7rem;
    border-radius: 999px;
    background: rgba(59, 130, 246, 0.12);
    color: #1d4ed8;
    font-weight: 600;
    font-size: 0.95rem;
  }

  [data-theme="dark"] .tmux-card .tmux-name {
    background: rgba(96, 165, 250, 0.15);
    color: #93c5fd;
  }
  .tmux-card-actions {
    margin-top: 1rem;
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
  }
  .tmux-card-actions .tertiary {
    border: none;
    background: transparent;
    color: #1e3a8a;
    cursor: pointer;
    padding: 0.35rem 0.4rem;
  }
  .tmux-card-actions .tertiary:hover {
    text-decoration: underline;
  }
  [data-theme="dark"] .tmux-card-actions .tertiary {
    color: #bfdbfe;
  }

  .text-muted {
    color: #64748b;
    font-size: 0.9rem;
  }

  [data-theme="dark"] .text-muted {
    color: rgba(203, 213, 225, 0.78);
  }

  /* Resumable Sessions Styling */
  .resumable-sessions {
    margin: 2rem 0;
  }

  .session-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }

  .session-card {
    border: 1px solid rgba(148, 163, 184, 0.25);
    border-radius: 0.75rem;
    padding: 1.25rem;
    background: white;
    transition: all 0.2s;
  }

  [data-theme="dark"] .session-card {
    background: rgba(30, 41, 59, 0.4);
    border-color: rgba(148, 163, 184, 0.3);
  }

  .session-card:hover {
    border-color: rgba(59, 130, 246, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .session-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .session-tool-badge {
    display: inline-flex;
    padding: 0.25rem 0.65rem;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.75rem;
    text-transform: uppercase;
  }

  .session-tool-badge.claude {
    background: rgba(168, 85, 247, 0.15);
    color: #7c3aed;
  }

  .session-tool-badge.codex {
    background: rgba(34, 197, 94, 0.15);
    color: #16a34a;
  }

  [data-theme="dark"] .session-tool-badge.claude {
    background: rgba(168, 85, 247, 0.2);
    color: #c084fc;
  }

  [data-theme="dark"] .session-tool-badge.codex {
    background: rgba(34, 197, 94, 0.2);
    color: #4ade80;
  }

  .session-meta {
    font-size: 0.85rem;
    color: #64748b;
    margin: 0.5rem 0;
  }

  [data-theme="dark"] .session-meta {
    color: rgba(203, 213, 225, 0.78);
  }

  .session-actions {
    margin-top: 1rem;
    display: flex;
    gap: 0.5rem;
  }

  .session-actions button {
    flex: 1;
  }
</style>
<script>
  // Load resumable sessions
  async function loadResumableSessions() {
    const sessionList = document.getElementById('session-list');
    if (!sessionList) return;

    try {
      console.log('Loading resumable sessions from:', `/projects/${projectId}/ai/sessions/resumable`);
      const response = await fetch(`/projects/${projectId}/ai/sessions/resumable`, {
        headers: {
          'Accept': 'application/json',
          ...csrfHeaders
        }
      });

      console.log('Response status:', response.status, 'Headers:', response.headers);
      const data = await parseJsonResponse(response, {
        errorMessage: 'Failed to load sessions',
        invalidBodyMessage: 'Received an invalid sessions response.',
      });
      const sessions = data.sessions || [];
      console.log('Loaded sessions:', sessions);

      if (sessions.length === 0) {
        sessionList.innerHTML = '<p class="text-muted">No resumable sessions found. Start a new AI session to create one.</p>';
        return;
      }

      // Render session cards
      sessionList.innerHTML = sessions.map(session => {
        const elapsed = formatElapsed(session.elapsed_seconds);
        const startedAt = new Date(session.started_at).toLocaleString();

        return `
          <article class="session-card">
            <div class="session-card-header">
              <span class="session-tool-badge ${session.tool}">${session.tool}</span>
              ${session.is_active ? '<span style="color: #10b981; font-size: 0.85rem;">●</span>' : ''}
            </div>
            ${session.description ? `<p>${escapeHtml(session.description)}</p>` : ''}
            <div class="session-meta">
              <div><strong>Owner:</strong> ${escapeHtml(session.user_name || 'Unknown')}</div>
              <div><strong>Session:</strong> <code>${escapeHtml(session.tmux_target || 'N/A')}</code></div>
              <div>Started: ${startedAt}</div>
              <div>Duration: ${elapsed}</div>
              ${session.branch ? `<div>Branch: <code>${escapeHtml(session.branch)}</code></div>` : ''}
            </div>
            <div class="session-actions">
              <button type="button" class="resume-session" data-session-id="${session.id}">
                Resume
              </button>
              <button type="button" class="secondary copy-resume-cmd" data-resume-command="${escapeHtml(session.resume_command)}">
                Copy Command
              </button>
              <button type="button" class="close-session" data-tmux-target="${escapeHtml(session.tmux_target)}" data-session-id="${session.id}" title="Close session" style="padding: 0.3rem 0.45rem; font-size: 1.1rem; background: #f8f9fa; border: 1px solid #dc2626; color: #dc2626; border-radius: 0.35rem; cursor: pointer; font-weight: bold;">
                ×
              </button>
            </div>
          </article>
        `;
      }).join('');

      // Attach event handlers
      attachSessionEventHandlers();

    } catch (error) {
      console.error('Error loading sessions:', error);
      sessionList.innerHTML = '<p class="text-muted">Failed to load resumable sessions.</p>';
    }
  }

  let sessionHandlerAttached = false;

  function attachSessionEventHandlers() {
    const sessionList = document.getElementById('session-list');
    if (!sessionList || sessionHandlerAttached) return;

    // Mark that we've attached the handler
    sessionHandlerAttached = true;

    // Use event delegation to handle resume and copy buttons
    sessionList.addEventListener('click', function(event) {
      const button = event.target.closest('button');
      if (!button) return;

      if (button.classList.contains('resume-session')) {
        handleResumeSession(event);
      } else if (button.classList.contains('copy-resume-cmd')) {
        const cmd = button.getAttribute('data-resume-command');
        navigator.clipboard.writeText(cmd).then(() => {
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy Command';
          }, 2000);
        });
      } else if (button.classList.contains('close-session')) {
        event.preventDefault();
        // Prevent duplicate clicks by disabling immediately
        if (button.disabled) return;

        const tmuxTarget = button.getAttribute('data-tmux-target');
        const sessionId = button.getAttribute('data-session-id');

        if (!tmuxTarget) {
          console.warn('No tmux_target for session', sessionId);
          return;
        }

        if (!confirm(`Are you sure you want to close this session?`)) {
          return;
        }

        const url = `/projects/${projectId}/tmux/close`;
        const originalLabel = button.textContent;
        button.disabled = true;
        button.textContent = 'Closing...';

        fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...csrfHeaders,
          },
          body: JSON.stringify({
            tmux_target: tmuxTarget,
          }),
        })
        .then(response => response.json().then(data => ({ ok: response.ok, data })))
        .then(({ ok, data }) => {
          if (ok) {
            // Remove the session card
            const sessionCard = button.closest('.session-card');
            if (sessionCard) {
              sessionCard.remove();
            }
            // Show warning if tmux close failed but database was updated
            if (data.warning) {
              console.warn(data.warning);
              alert(`Session closed (with warning): ${data.warning}`);
            }
          } else {
            throw new Error(data.error || 'Failed to close session.');
          }
        })
        .catch(error => {
          alert(`Error: ${error.message}`);
          button.disabled = false;
          button.textContent = originalLabel;
        });
      }
    });
  }

  async function handleResumeSession(event) {
    const button = event.target;
    const dbSessionId = button.getAttribute('data-session-id');
    const originalText = button.textContent;

    button.disabled = true;
    button.textContent = 'Resuming...';

    try {
      const response = await fetch(`/projects/${projectId}/ai/sessions/${dbSessionId}/resume`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...csrfHeaders
        },
        body: JSON.stringify({
          rows: term.rows,
          cols: term.cols
        })
      });

      const data = await parseJsonResponse(response, {
        errorMessage: 'Failed to resume session',
        invalidBodyMessage: 'Received an invalid resume response.',
      });
      sessionId = data.session_id;  // Assign to global sessionId

      // Start streaming from the new session
      startSession(sessionId);

    } catch (error) {
      console.error('Error resuming session:', error);
      alert('Failed to resume session: ' + error.message);
      button.disabled = false;
      button.textContent = originalText;
    }
  }

  function formatElapsed(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Load sessions on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadResumableSessions);
  } else {
    loadResumableSessions();
  }
</script>
{% endblock %}
