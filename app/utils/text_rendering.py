"""Helpers for rendering user provided issue content safely."""

from __future__ import annotations

import re
from html.parser import HTMLParser
from typing import Iterable
from urllib.parse import urlsplit

import mistune
from markupsafe import Markup, escape

# Jira mention pattern: [~accountid:ID] or [~username]
_JIRA_MENTION_PATTERN = re.compile(r"\[~(?:accountid:)?([^\]]+)\]")

# Tags typically returned by providers such as Jira when rendering descriptions,
# plus tags generated by Markdown renderers.
_ALLOWED_TAGS: set[str] = {
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "del",
    "div",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "li",
    "ol",
    "p",
    "pre",
    "span",
    "strong",
    "table",
    "tbody",
    "td",
    "th",
    "thead",
    "tr",
    "u",
    "ul",
}
_SELF_CLOSING_TAGS = {"br", "hr"}
_ALLOWED_ATTRS: dict[str, set[str]] = {
    "a": {"href", "rel", "target", "title"},
    "code": {"class"},
    "div": {"class"},
    "span": {"class"},
    "table": {"class"},
    "td": {"colspan"},
    "th": {"colspan"},
}
_SAFE_URL_SCHEMES = {"http", "https", "mailto", "tel"}
_HTML_DETECTION_RE = re.compile(r"<\/?\w+[^>]*>")
_STRIP_CONTENT_TAGS = {"script", "style"}

# Patterns that suggest Markdown content (not exhaustive, but common indicators)
_MARKDOWN_PATTERNS = [
    re.compile(r"^#{1,6}\s+", re.MULTILINE),  # Headers
    re.compile(r"```[\s\S]*?```"),  # Code blocks
    re.compile(r"`[^`]+`"),  # Inline code
    re.compile(r"\[[^\]]+\]\([^\)]+\)"),  # Links
    re.compile(r"^\s*[-*+]\s+", re.MULTILINE),  # Unordered lists
    re.compile(r"^\s*\d+\.\s+", re.MULTILINE),  # Ordered lists
    re.compile(r"\*\*[^*]+\*\*"),  # Bold
    re.compile(r"__[^_]+__"),  # Bold (alternative)
    re.compile(r"\*[^*]+\*"),  # Italic
    re.compile(r"_[^_]+_"),  # Italic (alternative)
    re.compile(r"^\s*>\s+", re.MULTILINE),  # Blockquotes
    re.compile(r"^\s*[-*_]{3,}\s*$", re.MULTILINE),  # Horizontal rules
    re.compile(r"- \[[x ]\]", re.IGNORECASE),  # Checkboxes
]

# Create a Mistune instance for rendering Markdown
_markdown_renderer = mistune.create_markdown(
    plugins=["strikethrough", "footnotes", "table", "task_lists"]
)


def _is_safe_url(value: str) -> bool:
    stripped = value.strip()
    if not stripped:
        return False
    split = urlsplit(stripped)
    if split.scheme:
        return split.scheme.lower() in _SAFE_URL_SCHEMES
    # Permit fragment or relative links within the tracker detail context.
    return stripped.startswith(("/", "#"))


def _sanitize_attribute(name: str, value: str) -> str | None:
    if name == "href":
        return value if _is_safe_url(value) else None
    if name == "target":
        return value if value in {"_blank", "_self"} else None
    return value


class _IssueHTMLSanitizer(HTMLParser):
    """Basic HTML sanitizer that preserves a limited set of markup."""

    def __init__(self) -> None:
        super().__init__(convert_charrefs=True)
        self._parts: list[str] = []
        self._strip_content_depth = 0

    def _serialize_attrs(
        self, tag: str, attrs: Iterable[tuple[str, str | None]]
    ) -> str:
        allowed = _ALLOWED_ATTRS.get(tag)
        if not allowed:
            return ""

        serialized: list[str] = []
        for name, raw_value in attrs:
            if raw_value is None or name not in allowed:
                continue
            sanitized = _sanitize_attribute(name, raw_value)
            if sanitized is None:
                continue
            serialized.append(f' {name}="{escape(sanitized)}"')
        return "".join(serialized)

    def handle_starttag(self, tag: str, attrs) -> None:  # type: ignore[override]
        tag_lower = tag.lower()
        if tag_lower in _STRIP_CONTENT_TAGS:
            self._strip_content_depth += 1
            return
        if tag_lower not in _ALLOWED_TAGS:
            return
        attr_string = self._serialize_attrs(tag_lower, attrs)
        self._parts.append(f"<{tag_lower}{attr_string}>")

    def handle_startendtag(self, tag: str, attrs) -> None:  # type: ignore[override]
        tag_lower = tag.lower()
        if tag_lower in _STRIP_CONTENT_TAGS:
            return
        if tag_lower not in _ALLOWED_TAGS:
            return
        attr_string = self._serialize_attrs(tag_lower, attrs)
        if tag_lower in _SELF_CLOSING_TAGS:
            self._parts.append(f"<{tag_lower}{attr_string}>")
            return
        self._parts.append(f"<{tag_lower}{attr_string}></{tag_lower}>")

    def handle_endtag(self, tag: str) -> None:  # type: ignore[override]
        tag_lower = tag.lower()
        if tag_lower in _STRIP_CONTENT_TAGS:
            if self._strip_content_depth:
                self._strip_content_depth -= 1
            return
        if tag_lower not in _ALLOWED_TAGS or tag_lower in _SELF_CLOSING_TAGS:
            return
        self._parts.append(f"</{tag_lower}>")

    def handle_data(self, data: str) -> None:  # type: ignore[override]
        if self._strip_content_depth:
            return
        self._parts.append(str(escape(data)))

    def get_html(self) -> str:
        return "".join(self._parts)


def _sanitize_html(html: str) -> str:
    parser = _IssueHTMLSanitizer()
    parser.feed(html)
    parser.close()
    return parser.get_html()


def _looks_like_html(text: str) -> bool:
    return bool(_HTML_DETECTION_RE.search(text))


def _looks_like_markdown(text: str) -> bool:
    """Detect if text contains Markdown syntax."""
    # Check for markdown patterns
    matches = sum(1 for pattern in _MARKDOWN_PATTERNS if pattern.search(text))
    # If we find any markdown pattern, treat it as markdown
    # (GitHub, GitLab, and other providers use markdown syntax)
    return matches >= 1


def _convert_jira_mentions(text: str) -> str:
    """Convert Jira mentions [~accountid:...] to readable format.

    Converts [~accountid:ID] or [~username] patterns to
    @username format that's more readable.

    Examples:
    - [~accountid:557058:5010d224-...] → @user:557058
    - [~jsmith] → @jsmith
    """
    def replace_mention(match):
        mention_id = match.group(1)
        display_name = mention_id

        # If it's an account ID with multiple parts, try to extract a meaningful name
        if ':' in mention_id:
            parts = mention_id.split(':')
            # Usually: numeric_id:uuid format
            # Prefer the numeric ID as it's more compact and stable
            if len(parts) >= 2 and parts[0]:
                # Show the numeric ID (e.g., 557058)
                display_name = f"user:{parts[0]}"
            elif len(parts) >= 2:
                # Fall back to showing a shortened UUID (first 8 chars)
                display_name = parts[-1][:8] if parts[-1] else "user"

        return f'<span class="jira-mention">@{escape(display_name)}</span>'

    return _JIRA_MENTION_PATTERN.sub(replace_mention, text)


def render_issue_rich_text(value: str | None) -> Markup:
    """Render stored issue content (plain text, Markdown, or HTML) safely for templates."""
    if not value:
        return Markup("")

    stripped = value.strip()
    if not stripped:
        return Markup("")

    # First, convert Jira mentions to readable format
    with_mentions = _convert_jira_mentions(stripped)

    # Check if it's HTML first (most explicit format)
    if _looks_like_html(with_mentions):
        sanitized = _sanitize_html(with_mentions)
        if sanitized:
            # If HTML only contains our jira-mention spans + plain text, convert newlines to <br>
            # This handles the common case of plain text with Jira mentions
            if '<span class="jira-mention">' in sanitized:
                # Replace newlines with <br> in the sanitized HTML
                # This preserves the mention spans while adding line breaks
                sanitized = sanitized.replace("\n", "<br>")
            return Markup(sanitized)

    # Check if it's Markdown
    if _looks_like_markdown(with_mentions):
        # Render Markdown to HTML
        markdown_result = _markdown_renderer(with_mentions)
        # Mistune can return str or list depending on renderer, we expect str
        if isinstance(markdown_result, str):
            # Sanitize the resulting HTML to ensure safety
            sanitized = _sanitize_html(markdown_result)
            if sanitized:
                return Markup(sanitized)

    # Fall back to treating the text as plain content and preserve newlines.
    escaped = str(escape(with_mentions))
    return Markup(escaped.replace("\n", "<br>"))
